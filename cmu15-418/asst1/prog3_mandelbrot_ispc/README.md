```bash
make
./mandelbrot_ispc
```

task_1.sh to the part1
task_2.sh to the part2 
task_3.sh to the part3

```bash
chmod +x task_1.sh task_2.sh task_3.sh
./task_1.sh
./task_2.sh
./task_3.sh
```
### **Pthread 与 ISPC 任务抽象的区别：**

#### **1. Pthread 的任务抽象：**

- **创建与销毁：**  
  在 Pthread 中，每个线程通过 **`pthread_create()`** 创建，并且通过 **`pthread_join()`** 等待线程结束。如果需要并行任务，则必须明确创建多个线程，并在任务完成后逐一回收（join）。
  
- **系统级线程：**  
  Pthread 是**系统级线程**，每个线程都有独立的栈空间、线程上下文和调度信息。这意味着创建、管理和销毁线程的成本较高。

- **同步机制：**  
  多个线程间如果共享资源，必须通过 **锁（mutex）、条件变量（condition variable）** 等手动同步。这些同步机制虽然灵活，但增加了编程复杂性和调度开销。

- **调度：**  
  操作系统负责线程的调度，每个 Pthread 线程可能会在不同的 CPU 核心上执行。线程间频繁的上下文切换会影响性能。

---

#### **2. ISPC 的任务抽象：**

- **轻量级任务：**  
  ISPC 的任务不是系统级线程，而是更轻量级的 **任务（task）**。它们由 ISPC 编译器和运行时管理，并通过 **`launch`** 创建任务，通过 **`sync`** 等待任务完成。

- **线程池与 SIMD 优化：**  
  ISPC 在内部使用 **线程池** 和 **SIMD 指令**执行任务，减少了频繁创建和销毁线程的开销。每个任务只是一段代码逻辑，并在已有的线程池中运行。

- **任务映射与调度：**  
  ISPC 会将多个任务映射到可用的 CPU 核心，并充分利用 **SIMD 单元**来进行数据并行，减少了调度开销。

- **自动负载均衡：**  
  ISPC 的任务可以**动态调度**到不同核心，不需要开发者手动管理线程之间的同步。

---

### **思考题：10,000 个 ISPC 任务与 10,000 个 Pthread 线程**

#### **1. 启动 10,000 个 ISPC 任务会发生什么？**

- **线程池执行**：  
  ISPC 使用 **线程池**来处理任务，而不是为每个任务创建新线程。因此，即使启动 10,000 个任务，ISPC 也会在固定数量的线程上轮流执行这些任务。例如，如果系统有 8 个核心，ISPC 可能会创建 8 个线程，然后这些线程在 10,000 个任务之间循环执行。

- **负载均衡**：  
  由于 ISPC 的任务是轻量级的，多个任务之间的调度成本很低。任务会被自动分配给空闲的线程执行，避免了频繁的上下文切换。

- **内存开销小**：  
  ISPC 任务不会为每个任务分配独立的栈空间，而是使用共享的线程栈。因此，即使有大量任务，内存开销也较低。

- **性能保持较高**：  
  10,000 个 ISPC 任务不会对系统资源造成太大压力，因为它们不会创建大量线程，而是依赖已有的线程池进行调度。

---

#### **2. 启动 10,000 个 Pthread 线程会发生什么？**

- **大量资源消耗**：  
  每个 Pthread 线程都需要独立的栈空间（通常为 1-2 MB），因此 10,000 个线程会占用大量内存（大约 10-20 GB）。这可能导致系统内存耗尽或性能严重下降。

- **高调度开销**：  
  操作系统需要在这 10,000 个线程之间频繁进行上下文切换，每次切换都会保存和恢复线程状态，导致调度成本很高。

- **崩溃风险**：  
  系统可能无法处理如此多的线程，导致程序崩溃或性能严重退化。此外，线程之间如果需要共享数据，必须进行大量的同步，进一步增加了开销。

---

### **总结：Pthread 与 ISPC 任务机制的优劣**

| 特性                    | Pthread 线程                         | ISPC 任务                      |
|------------------------|------------------------------------|-------------------------------|
| **创建开销**            | 高，每个线程需要独立栈和上下文       | 低，通过线程池管理            |
| **调度开销**            | 高，操作系统频繁进行上下文切换       | 低，任务在固定线程池中调度     |
| **内存消耗**            | 高，每个线程需要独立栈               | 低，共享线程栈                 |
| **同步复杂度**          | 高，需要手动同步                    | 低，由 ISPC 自动管理           |
| **适用场景**            | 适合少量长时间运行的线程            | 适合大量轻量级并行任务         |

---

### **结论：ISPC 任务的优势**

- 如果你启动 **10,000 个 ISPC 任务**，ISPC 会通过线程池管理这些任务，不会造成系统资源的严重消耗，也不会出现频繁的上下文切换。任务之间的调度由 ISPC 自动完成，性能保持较高。

- 如果你启动 **10,000 个 Pthread 线程**，系统会因为内存不足或频繁的上下文切换而崩溃或变得极慢。这表明，**Pthread 适合少量长时间运行的任务**，而 **ISPC 更适合大量轻量级并行任务**。

ISPC 的 **任务抽象** 提供了更轻量级的并行方式，使得它在处理大量并行任务时更加高效和可靠。